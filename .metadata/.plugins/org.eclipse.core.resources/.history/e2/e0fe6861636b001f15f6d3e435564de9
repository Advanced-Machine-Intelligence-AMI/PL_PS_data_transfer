/*
 * rx_intr_pl_ps.c
 *
 *  Created on: 05-Sep-2024
 *      Author: KrishnaVamshi(ELD-IN
 */
#include <stdio.h>
#include "xil_printf.h"
#include "xparameters.h"
#include "xaxidma.h"
#include "xscugic.h"
#include "xil_exception.h"

#define DMA_DEVICE_ID  XPAR_AXIDMA_1_DEVICE_ID
#define DDR_BASE_ADDRESS    XPAR_PSU_DDR_0_S_AXI_BASEADDR
#define MEM_BASE_ADDR       (DDR_BASE_ADDRESS + 0x1000000)
#define RX_BUFFER_BASE      (MEM_BASE_ADDR + 0x00300000)
#define RX_BUFFER_HIGH      (MEM_BASE_ADDR + 0x004FFFFF)
#define RX_INTR_ID          XPAR_FABRIC_AXIDMA_1_S2MM_INTROUT_VEC_ID
#define INTC_DEVICE_ID      XPAR_SCUGIC_SINGLE_DEVICE_ID
#define RESET_TIMEOUT_COUNTER 10000
#define MAX_PKT_LEN         0x32  // Example packet length, adjust as needed

static XAxiDma AxiDma; // Instance of the DMA engine
static XScuGic Intc;   // Interrupt controller

volatile u32 RxDone;
volatile u32 Error;

// RX Interrupt Handler
static void RxIntrHandler(void *Callback);

// Setup Interrupts
static int SetupIntrSystem(XScuGic *IntcInstancePtr, XAxiDma *AxiDmaPtr, u16 RxIntrId);

// Disable Interrupt System
static void DisableIntrSystem(XScuGic *IntcInstancePtr, u16 RxIntrId);

int main(void)
{
    int Status;
    XAxiDma_Config *Config;
    u8 *RxBufferPtr;

    xil_printf("Entering main()\r\n");

    // Initialize DMA engine
    Config = XAxiDma_LookupConfig(DMA_DEVICE_ID);
    if (!Config) {
        xil_printf("No config found for DMA device ID %d\r\n", DMA_DEVICE_ID);
        return XST_FAILURE;
    }

    Status = XAxiDma_CfgInitialize(&AxiDma, Config);
    if (Status != XST_SUCCESS) {
        xil_printf("DMA initialization failed\r\n");
        return XST_FAILURE;
    }

    if (XAxiDma_HasSg(&AxiDma)) {
        xil_printf("Device configured in SG mode. Unsupported.\r\n");
        return XST_FAILURE;
    }

    // Setup interrupts for RX only
    Status = SetupIntrSystem(&Intc, &AxiDma, RX_INTR_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("Failed to setup interrupts\r\n");
        return XST_FAILURE;
    }

    // Initialize flags
    RxDone = 0;
    Error = 0;

    // Prepare buffer for RX
    RxBufferPtr = (u8 *)RX_BUFFER_BASE;
    Xil_DCacheFlushRange((UINTPTR)RxBufferPtr, MAX_PKT_LEN);

    xil_printf("Waiting for data from PL via DMA...\r\n");

    // Wait for interrupt indicating data reception
    while (!RxDone && !Error);

    if (Error) {
        xil_printf("DMA Error occurred\r\n");
    } else {
        xil_printf("Data received successfully\r\n");
    }

    // Disable interrupts
    DisableIntrSystem(&Intc, RX_INTR_ID);

    xil_printf("Exiting main()\r\n");
    return XST_SUCCESS;
}

/****************************************************************************/
/**
* This is the DMA RX interrupt handler function
*
* @param   Callback is a pointer to RX channel of the DMA engine.
*
* @return  None.
*
****************************************************************************/
static void RxIntrHandler(void *Callback)
{
    u32 IrqStatus;
    int Timeout;
    XAxiDma *AxiDmaInst = (XAxiDma *)Callback;

    /* Read pending Interrupts */
    IrqStatus = XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DEVICE_TO_DMA);

    /* Acknowledge pending Interrupts */
    XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DEVICE_TO_DMA);

    /* If no interrupt is asserted, return */
    if (!(IrqStatus & XAXIDMA_IRQ_ALL_MASK)) {
        return;
    }

    /* If error interrupt is asserted, raise error flag, reset the hardware */
    if (IrqStatus & XAXIDMA_IRQ_ERROR_MASK) {
        Error = 1;
        XAxiDma_Reset(AxiDmaInst);

        Timeout = RESET_TIMEOUT_COUNTER;
        while (Timeout) {
            if (XAxiDma_ResetIsDone(AxiDmaInst)) {
                break;
            }
            Timeout -= 1;
        }
        return;
    }

    /* If completion interrupt is asserted, set the RxDone flag */
    if (IrqStatus & XAXIDMA_IRQ_IOC_MASK) {
        RxDone = 1;
    }
}

/****************************************************************************/
/**
* This function sets up the interrupt system
*
* @param   IntcInstancePtr is the pointer to the interrupt controller instance
* @param   AxiDmaPtr is the pointer to the DMA instance
* @param   RxIntrId is the RX interrupt ID
*
* @return  XST_SUCCESS if successful, XST_FAILURE otherwise.
*
****************************************************************************/
static int SetupIntrSystem(XScuGic *IntcInstancePtr, XAxiDma *AxiDmaPtr, u16 RxIntrId)
{
    int Status;
    XScuGic_Config *IntcConfig;

    // Initialize interrupt controller driver
    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (IntcConfig == NULL) {
        return XST_FAILURE;
    }

    Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    // Connect the interrupt handler for the RX channel
    Status = XScuGic_Connect(IntcInstancePtr, RxIntrId, (Xil_ExceptionHandler)RxIntrHandler, AxiDmaPtr);
    if (Status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    XScuGic_Enable(IntcInstancePtr, RxIntrId);

    // Enable exception handling
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, IntcInstancePtr);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

/****************************************************************************/
/**
* This function disables the interrupt system for the RX channel.
*
* @param   IntcInstancePtr is the pointer to the interrupt controller instance
* @param   RxIntrId is the RX interrupt ID
*
* @return  None.
*
****************************************************************************/
static void DisableIntrSystem(XScuGic *IntcInstancePtr, u16 RxIntrId)
{
    XScuGic_Disconnect(IntcInstancePtr, RxIntrId);
}


